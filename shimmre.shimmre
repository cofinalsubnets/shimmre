_ <- -[\s]+

parse <- mainP | sub

mainP <- -'main' _ sub

sub <- atom _? -'<-' _? alt

compile <- atom _? -'->' code
code <- ([\S ] | &([\n] [\s]) [\n])*

atom <- [a-zA-Z_] [a-zA-Z0-9_'-]*

term <- -'"' ('\"' | [^"])* -'"'
      | -"'" ("\'" | [^'])* -"'"

ruleInit <- ('main' _)? atom _ '<-'
          | atom _ '->'

expr <- rAtom | term | charopt | paren
rAtom <- !ruleInit atom

rep  <- expr _? -'*'
opt  <- expr _? -'?'
plus <- expr _? -'+'
expr'  <- rep | opt | plus | expr

not  <- -'!' _? expr'
and  <- -'&' _? expr'
drop <- -'-' _? expr'
expr'' <- not | and | drop | expr'

cat <- expr'' (_ cat)?
alt <- cat (_? -'|' _? alt)?

paren <- -'(' _? alt _? -')'

charopt <- '[' ('\]' | [^\]])* ']'

init <- -''
rule <- parse | compile
main rules <- init (_? rule)+ _?

init ->
  this.rules = {};
  this.context = {rules: this.rules};
  this.match = function (a,b) {return {val:a, rem:b};};
  this.map = function (mf,f) {
    return function (s) {
      var res = mf(s);
      return res && this.match(f(res.val), res.rem);
    };
  };

atom -> return $.join('')
rAtom -> var rs = this.rules; return function (s) { return rs[$](s); };

term ->
  return function(s) {
    return s.substr(0, $[0].length) === $[0] && this.match ([$[0]], s.slice($[0].length));
  }

alt  -> return $.reduce(function(a,b) { return function(s) { return a(s) || b(s); }; });

cat  -> return $.reduce(function(a,b) { return function(s) {
    var t1, t2;
    return (t1 = a(s)) && (t2 = b(t1.rem)) && this.match(t1.val.concat(t2.val), t2.rem);
  }});

rep  ->
  return function (s) {
    var r;
    return (r = $[0](s)) && this.map(this.rules.rep($),
      function(a) {return r.val.concat(a);})(r.rem) || this.match([], s);
  };

not  -> return function(s) { return !$[0](s) && this.match([], s); }
opt  -> return function(s) { return $[0](s) || this.match([], s); }
and  -> return function(s) { return $[0](s) && this.match([], s); }
plus -> return this.rules.cat($[0], this.rules.rep($[0]));
drop -> return this.map($[0], function () {return [];})

charopt ->
  var re = RegExp('^' + $.join(''));
  return function (s) {
    var r;
    return (r = s.match(re) && this.match(r[0], s.slice(r[0].length)));
  }

sub ->
  this.currentRule = $[0];
  return this.rules[$[0]] = $[1];

rules -> return this.output;

mainP ->
  var rs = this.rules, cr = this.currentRule;
  return this.output = function (s) {return rs[cr](s);};

code -> return $.join('')

compile -> 
  var atom = $[0], code = $[1], rule;
  if (!(rule = this.rules[atom]))
    throw new ReferenceError(
      "Compile rule `" + atom + "' defined before parse rule");
  var tfn       = eval("(function ($) {"+code+"})"),
      context   = this.context,
      transform = function (argv) {
        var res = tfn.call(context, argv);
        if (!(res === null || res === undefined))
          return Array.isArray(res) ? res : [res];
        else return [];
      };
  return this.rules[atom] = this.map(rule, transform);

