_ <- -[\s]+

parse <- mainP | sub

mainP <- -'main' _ sub

sub <- atom _? -'<-' _? alt

compile <- atom _? -'->' code
code <- ([\S ] | &([\n] [\s]) [\n])*

atom <- [a-zA-Z_] [a-zA-Z0-9_'-]*

term <- -'"' ('\"' | [^"])* -'"'
      | -"'" ("\'" | [^'])* -"'"

ruleInit <- ('main' _)? atom _ '<-'
          | atom _ '->'

expr <- rAtom | term | charopt | paren
rAtom <- !ruleInit atom

rep  <- expr _? -'*'
opt  <- expr _? -'?'
plus <- expr _? -'+'
expr'  <- rep | opt | plus | expr

not  <- -'!' _? expr'
and  <- -'&' _? expr'
drop <- -'-' _? expr'
expr'' <- not | and | drop | expr'

cat <- expr'' (_ cat)?
alt <- cat (_? -'|' _? alt)?

paren <- -'(' _? alt _? -')'

charopt <- '[' ('\]' | [^\]])* ']'

init <- -''
rule <- parse | compile
main rules <- init (_? rule)+ _?

init ->
  this.rules = {};
  this.context = {};
  var map = this.map = function (mf,f) {
    return function (s) {
      var res = mf(s);
      return res && {val: f(res.val), rem: res.rem};
    };
  };
  this.cat = function(a,b) { return function(s) {
    var t1, t2;
    return (t1 = a(s)) && (t2 = b(t1.rem)) && {val: t1.val.concat(t2.val), rem: t2.rem};
  }};
  var rep = this.rep = function (m) { return function (s) {
    var r;
    return (r = m(s)) && map(rep(m),
      function(a) {return r.val.concat(a);})(r.rem) || {val: [], rem: s};
  }};

atom -> return $.join('')
rAtom -> var rs = this.rules; return function (s) { return rs[$](s); };

term ->
  return function(s) {
    return s.substr(0, $[0].length) === $[0] && {val: [$[0]], rem: s.slice($[0].length)};
  }

alt  -> return $.reduce(function(a,b) { return function(s) { return a(s) || b(s); }; });

cat  -> return $.reduce(this.cat);

rep  -> return this.rep($[0]);

not  -> return function(s) { return !$[0](s) && {val: [], rem: s}; }
opt  -> return function(s) { return $[0](s) || {val: [], rem: s}; }
and  -> return function(s) { return $[0](s) && {val: [], rem: s}; }
plus -> return this.rules.cat($[0], this.rules.rep($[0]));
drop -> return this.map($[0], function () {return [];})

charopt ->
  var re = RegExp('^' + $.join(''));
  return function (s) {
    var r;
    return (r = s.match(re) && {val: r[0], rem: s.slice(r[0].length)});
  }

sub ->
  this.currentRule = $[0];
  return this.rules[$[0]] = $[1];

rules -> return this.output;

mainP ->
  var rs = this.rules, cr = this.currentRule;
  return this.output = function (s) {return rs[cr](s);};

code -> return $.join('')

compile -> 
  var atom = $[0], code = $[1], rule;
  if (!(rule = this.rules[atom]))
    throw new ReferenceError(
      "Compile rule `" + atom + "' defined before parse rule");
  var tfn       = eval("(function ($) {"+code+"})"),
      context   = this.context,
      transform = function (argv) {
        var res = tfn.call(context, argv);
        if (!(res === null || res === undefined))
          return Array.isArray(res) ? res : [res];
        else return [];
      };
  return this.rules[atom] = this.map(rule, transform);

